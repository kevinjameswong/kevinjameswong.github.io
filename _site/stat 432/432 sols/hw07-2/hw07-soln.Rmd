---
title: "STAT 432 Homework 07"
author: "Spring 2018 | Dalpiaz | UIUC"
date: '**Due:** Friday, April 6, 11:59 PM'
---

***

For this homework, you may only use the following packages:

```{r, message = FALSE, warning = FALSE}
# general
library(MASS)
library(caret)
library(tidyverse)
library(knitr)
library(kableExtra)
library(mlbench)

# specific
library(ISLR)
library(ellipse)
library(randomForest)
library(gbm)
library(glmnet)
library(rpart)
library(rpart.plot)
```

***

# Exercise 1 (Classifying Leukemia)

**[7 points]** For this question we will use the data in [`leukemia.csv`](leukemia.csv) which originates from [Golub et al. 1999.](http://www.ncbi.nlm.nih.gov/pubmed/10521349)

The response variable `class` is a categorical variable. There are two possible responses: `ALL` (acute myeloid leukemia) and `AML` (acute lymphoblastic leukemia), both types of leukemia. We will use the many feature variables, which are expression levels of genes, to predict these classes.

Note that, this dataset is rather large and you may have difficultly loading it using the "Import Dataset" feature in RStudio. Instead place the file in the same folder as your `.Rmd` file and run the following command. (Which you should be doing anyway.) Again, since this dataset is large, use 5-fold cross-validation when needed.

```{r, message = FALSE, warning = FALSE}
leukemia = read_csv("leukemia.csv", progress = FALSE)
```

For use with the `glmnet` package, it will be useful to create a factor response variable `y` and a feature matrix `X` as seen below. We won't test-train split the data since there are so few observations.

```{r}
y = as.factor(leukemia$class)
X = as.matrix(leukemia[, -1])
```

Do the following:

- Set a seed equal to your UIN.
- Fit the full path of a logistic regression with both a lasso penalty and a ridge penalty. (Don't use cross-validation. Also let `glmnet` choose the $\lambda$ values.) Create side-by-side plots that shows the features entering (or leaving) the models.
- Use cross-validation to tune an logistic regression with a lasso penalty. Again, let `glmnet` choose the $\lambda$ values. Store both the $\lambda$ that minimizes the deviance, as well as the $\lambda$ that has a deviance within one standard error. Create a plot of the deviances for each value of $\lambda$ considered. Use these two $\lambda$ values to create a grid for use with `train()` in `caret`. Use `train()` to get cross-validated classification accuracy for these two values of $\lambda$. Store these values.
- Use cross-validation to tune an logistic regression with a ridge penalty. Again, let `glmnet` choose the $\lambda$ values. Store both the $\lambda$ that minimizes the deviance, as well as the $\lambda$ that has a deviance within one standard error. Create a plot of the deviances for each value of $\lambda$ considered. Use these two $\lambda$ values to create a grid for use with `train()` in `caret`. Use `train()` to get cross-validated classification accuracy for these two values of $\lambda$. Store these values.
- Use cross-validation to tune $k$-nearest neighbors using `train()` in `caret`. Do not specify a grid of $k$ values to try, let `caret` do so automatically. (It will use 5, 7, 9.) Store the cross-validated accuracy for each. Scale the predictors.
- Summarize these **seven** models in a table. (Two lasso, two ridge, three knn.) For each report the cross-validated accuracy and the standard deviation of the accuracy.

**Solution:**

```{r, message = FALSE, warning = FALSE, solution = TRUE}
uin = 123456789
set.seed(uin)
cv_5 = trainControl(method = "cv", number = 5)
```

```{r, solution = TRUE}
fit_lasso = glmnet(X, y, family = "binomial", alpha = 1)
fit_ridge = glmnet(X, y, family = "binomial", alpha = 0)
```

```{r fig.height = 7, fig.width = 13, solution = TRUE, fig.align = "center"}
par(mfrow = c(1, 2))
plot(fit_lasso, xvar = "lambda", main = "Lasso")
plot(fit_ridge, xvar = "lambda", main = "Ridge")
```

```{r, solution = TRUE, fig.align = "center"}
fit_lasso_cv = cv.glmnet(X, y, family = "binomial", alpha = 1, nfolds = 5)
plot(fit_lasso_cv)
```

```{r, solution = TRUE}
lambda_lasso = expand.grid(alpha = 1, 
                           lambda = c(fit_lasso_cv$lambda.min,
                                      fit_lasso_cv$lambda.1se))
```

```{r, solution = TRUE}
train_lasso = train(X, y, 
                    method = "glmnet", 
                    trControl = cv_5,
                    tuneGrid = lambda_lasso)
```

```{r, solution = TRUE, fig.align = "center"}
fit_ridge_cv = cv.glmnet(X, y, family = "binomial", alpha = 0, nfolds = 5)
plot(fit_ridge_cv)
```

```{r, solution = TRUE}
lambda_ridge = expand.grid(alpha = 0, 
                           lambda = c(fit_ridge_cv$lambda.min, 
                                      fit_ridge_cv$lambda.1se))
```

```{r, solution = TRUE}
train_ridge = train(X, y, 
                    method = "glmnet", 
                    trControl = cv_5,
                    tuneGrid = lambda_ridge)
```

```{r, solution = TRUE}
train_knn = train(X, y, 
                  method = "knn",
                  preProc = c("center", "scale"),
                  trControl = cv_5)
```

```{r, solution = TRUE, echo = FALSE}
method = c("Lasso", "Lasso", "Ridge", "Ridge", "KNN", "KNN", "KNN")
param = c("`lambda`", "`lambda`", "`lambda`", "`lambda`", "`k`", "`k`", "`k`")
cv_acc = c(train_lasso$results$Accuracy, train_ridge$results$Accuracy, train_knn$results$Accuracy)
sd_cv_acc = c(train_lasso$results$AccuracySD, train_ridge$results$AccuracySD, train_knn$results$AccuracySD)
param_value = c(train_lasso$results$lambda, train_ridge$results$lambda, train_knn$results$k)

leuk_results = data.frame(method, param, param_value, cv_acc, sd_cv_acc)
colnames(leuk_results) = c("Method", "Parameter", "Parameter Value", "CV-5 Accuracy", "Standard Deviation")
kable_styling(kable(leuk_results, format = "html", digits = 3), full_width = FALSE)
```

***

# Exercise 2 (The Cost of College)

**[5 points]** For this exercise, we will use the `College` data from the `ISLR` package. Familiarize yourself with this dataset before performing analyses. We will attempt to predict the `Outstate` variable.

Test-train split the data using this code.

```{r, message = FALSE, warning = FALSE}
set.seed(42)
index = createDataPartition(College$Outstate, p = 0.75, list = FALSE)
college_trn = College[index, ]
college_tst = College[-index, ]
```

Train a total of **six** models using five-fold cross validation.

- An additive linear model.
- An elastic net model using additive predictors. Use a `tuneLength` of `10`.
- An elastic net model that also considers all two-way interactions. Use a `tuneLength` of `10`.
- A well-tuned KNN model.
- A well-tuned KNN model that also considers all two-way interactions. (Should this work?)
- A default-tuned random forest.

Before beginning, set a seed equal to your UIN.

```{r}
uin = 123456789
set.seed(uin)
```

- Create a table which reports CV and Test RMSE for each.

**Solution:**

Note that some code, for plotting and summarizing, is hidden. See the .Rmd file for code.

```{r, solution = TRUE, echo = FALSE, fig.align = "center"}
theme1 <- trellis.par.get()
theme1$plot.symbol$col = rgb(.2, .2, .2, .4)
theme1$plot.symbol$pch = 16
theme1$plot.line$col = rgb(1, 0, 0, .7)
theme1$plot.line$lwd = 2
trellis.par.set(theme1)
featurePlot(x = college_trn[c("Expend", "S.F.Ratio", "Terminal", "PhD", "Personal", "Books")],
            y = college_trn$Outstate,
            plot = "scatter",
            type = c("p", "smooth"),
            span = .5)
```

```{r, solution = TRUE}
calc_rmse = function(actual, predicted) {
  sqrt(mean((actual - predicted) ^ 2))
}
```

```{r, solution = TRUE}
cv_5 = trainControl(method = "cv", number = 5)
```

```{r, solution = TRUE}
set.seed(uin)
fit_lm         = train(Outstate ~ ., data = college_trn, method = "lm", 
                       trControl = cv_5)
fit_glmnet     = train(Outstate ~ ., data = college_trn, method = "glmnet", 
                       trControl = cv_5, tuneLength = 10)
fit_glmnet_int = train(Outstate ~ . ^ 2, data = college_trn, method = "glmnet", 
                       trControl = cv_5, tuneLength = 10)
fit_knn        = train(Outstate ~ ., data = college_trn, method = "knn", 
                       trControl = cv_5, tuneLength = 25, 
                       preProcess = c("center", "scale"))
fit_knn_int    = train(Outstate ~ . ^ 2, data = college_trn, method = "knn", 
                       trControl = cv_5, tuneLength = 25, 
                       preProcess = c("center", "scale"))
fit_rf         = train(Outstate ~ ., data = college_trn, method = "rf", 
                       trControl = cv_5)
```

```{r, solution = TRUE}
get_best_result = function(caret_fit) {
  best = which(rownames(caret_fit$results) == rownames(caret_fit$bestTune))
  best_result = caret_fit$results[best, ]
  rownames(best_result) = NULL
  best_result
}
```

```{r, solution = TRUE, echo = FALSE}
models = c("Linear Model", "Elastic Net", "Elastic Net with Interactions", "KNN", "KNN with Interactions", "Random Forest")

cv_rmse = c(
  get_best_result(fit_lm)$RMSE,
  get_best_result(fit_glmnet)$RMSE,
  get_best_result(fit_glmnet_int)$RMSE,
  get_best_result(fit_knn)$RMSE,
  get_best_result(fit_knn_int)$RMSE,
  get_best_result(fit_rf)$RMSE
)

test_rmse = c(
  calc_rmse(predicted = predict(fit_lm, college_tst), actual = college_tst$Outstate),
  calc_rmse(predicted = predict(fit_glmnet, college_tst), actual = college_tst$Outstate),
  calc_rmse(predicted = predict(fit_glmnet_int, college_tst), actual = college_tst$Outstate),
  calc_rmse(predicted = predict(fit_knn, college_tst), actual = college_tst$Outstate),
  calc_rmse(predicted = predict(fit_knn_int, college_tst), actual = college_tst$Outstate),
  calc_rmse(predicted = predict(fit_rf, college_tst), actual = college_tst$Outstate)
)

class_results = data.frame(models, cv_rmse, test_rmse)
colnames(class_results) = c("Method", "CV RMSE", "Test RMSE")
kable_styling(kable(class_results, format = "html", digits = 3), full_width = FALSE)
```

***

# Exercise 3 (Computation Time)

**[5 points]** For this exercise we will create data via simulation, then assess how well certain methods perform. Use the code below to create a train and test dataset.

```{r, message = FALSE, warning = FALSE}
set.seed(42)
sim_trn = mlbench.spirals(n = 2500, cycles = 1.5, sd = 0.125)
sim_trn = data.frame(sim_trn$x, class = as.factor(sim_trn$classes))
sim_tst = mlbench.spirals(n = 10000, cycles = 1.5, sd = 0.125)
sim_tst = data.frame(sim_tst$x, class = as.factor(sim_tst$classes))
```

The training data is plotted below, with colors indicating the `class` variable, which is the response.

```{r, fig.height = 5, fig.width = 5, echo = FALSE, fig.align = "center"}
sim_trn_col = ifelse(sim_trn$class == 1, "darkorange", "dodgerblue")
plot(sim_trn$X1, sim_trn$X2, col = sim_trn_col,
     xlab = "X1", ylab = "X2", pch = 20)
```

Before proceeding further, set a seed equal to your UIN.

```{r}
uin = 123456789
set.seed(uin)
```

We'll use the following to define 5-fold cross-validation for use with `train()` from `caret`.

```{r, message = FALSE, warning = FALSE}
cv_5 = trainControl(method = "cv", number = 5)
```

We now tune two models with `train()`. First, a logistic regression using `glm`. (This actually isn't "tuned" as there are not parameters to be tuned, but we use `train()` to perform cross-validation.) Second we tune a single decision tree using `rpart`.

We store the results in `sim_glm_cv` and `sim_tree_cv` respectively, but we also wrap both function calls with `system.time()` in order to record how long the tuning process takes for each method.

```{r, message = FALSE, warning = FALSE}
glm_cv_time = system.time({
  sim_glm_cv  = train(
    class ~ .,
    data = sim_trn,
    trControl = cv_5,
    method = "glm")
})

tree_cv_time = system.time({
  sim_tree_cv = train(
    class ~ .,
    data = sim_trn,
    trControl = cv_5,
    method = "rpart")
})
```

We see that both methods are tuned via cross-validation in a similar amount of time.

```{r}
glm_cv_time["elapsed"]
tree_cv_time["elapsed"]
```

```{r, message = FALSE, warning = FALSE, echo = FALSE, fig.align = "center"}
rpart.plot(sim_tree_cv$finalModel)
```

Repeat the above analysis using a random forest, twice. The first time use 5-fold cross-validation. (This is how we had been using random forests before we understood random forests.) The second time, tune the model using OOB samples. We only have two predictors here, so, for both, use the following tuning grid.

```{r}
rf_grid = expand.grid(mtry = c(1, 2))
```

```{r, message = FALSE, warning = FALSE, solution = TRUE}
oob  = trainControl(method = "oob")
rf_oob_time = system.time({
  sim_rf_oob = train(
    class ~ .,
    data = sim_trn,
    trControl = oob,
    tuneGrid = rf_grid)
})

rf_cv_time = system.time({
  sim_rf_cv = train(
    class ~ .,
    data = sim_trn,
    trControl = cv_5,
    tuneGrid = rf_grid)
})
```

Create a table summarizing the results of these four models. (Logistic with CV, Tree with CV, RF with OOB, RF with CV). Report:

- Chosen value of tuning parameter (If applicable)
- Elapsed tuning time
- Resampled (CV or OOB) Accuracy
- Test Accuracy

```{r, solution = TRUE, echo = FALSE}
best_tune = c(NA, sim_tree_cv$bestTune$cp, sim_rf_oob$bestTune$mtry, sim_rf_cv$bestTune$mtry)

time_results = c(glm_cv_time["elapsed"], 
                 tree_cv_time["elapsed"], 
                 rf_oob_time["elapsed"], 
                 rf_cv_time["elapsed"])

resampled_acc = c(max(sim_glm_cv$results$Accuracy),
                  max(sim_tree_cv$results$Accuracy),
                  max(sim_rf_oob$results$Accuracy), 
                  max(sim_rf_cv$results$Accuracy))

calc_acc = function(actual, predicted) {
  mean(actual == predicted)
}

glm_cv_tst_acc = calc_acc(predicted = predict(sim_glm_cv, sim_tst),
                          actual    = sim_tst$class)

tree_cv_tst_acc = calc_acc(predicted = predict(sim_tree_cv, sim_tst),
                           actual    = sim_tst$class)

rf_cv_tst_acc = calc_acc(predicted = predict(sim_rf_cv, sim_tst),
                         actual    = sim_tst$class)

rf_oob_tst_acc = calc_acc(predicted = predict(sim_rf_oob, sim_tst),
                          actual    = sim_tst$class)

test_acc = c(glm_cv_tst_acc, tree_cv_tst_acc, rf_cv_tst_acc, rf_oob_tst_acc)
```

```{r, solution = TRUE, echo = FALSE}
timing_results = data.frame(
  c("Logistic, CV", "Tree, CV", "RF, OOB", "RF, CV"),
  best_tune,
  time_results,
  resampled_acc,
  test_acc
)
colnames(timing_results) = c("Method", "Best Tune", "Elapsed", "Resampled Accuracy", "Test Accuracy")
kable_styling(kable(timing_results, format = "html", digits = 4), full_width = FALSE)
```


# Exercise 4 (Predicting Baseball Salaries)

**[5 points]** For this question we will predict the `Salary` of `Hitters`. (`Hitters` is also the name of the dataset.) We first remove the missing data:

```{r}
Hitters = na.omit(Hitters)
```

After changing `uin` to your UIN, use the following code to test-train split the data.

```{r}
uin = 123456789
set.seed(uin)
hit_idx = createDataPartition(Hitters$Salary, p = 0.6, list = FALSE)
hit_trn = Hitters[hit_idx,]
hit_tst = Hitters[-hit_idx,]
```

Do the following:

- Tune a boosted tree model using the following tuning grid and 5-fold cross-validation.

```{r}
gbm_grid = expand.grid(interaction.depth = c(1, 2),
                       n.trees = c(500, 1000, 1500),
                       shrinkage = c(0.001, 0.01, 0.1),
                       n.minobsinnode = 10)
```

- Tune a random forest using OOB resampling and **all** possible values of `mtry`. 

Create a table summarizing the results of three models:

- Tuned boosted tree model
- Tuned random forest model
- Bagged tree model

For each, report:

- Resampled RMSE
- Test RMSE

```{r, solution = TRUE, message = FALSE, warning = FALSE}
hit_gbm = train(Salary ~ ., data = hit_trn,
                method = "gbm",
                trControl = cv_5,
                verbose = FALSE,
                tuneGrid = gbm_grid)

rf_grid = rf_grid = expand.grid(mtry = 1:(ncol(hit_trn) - 1))
hit_rf  = train(Salary ~ ., data = hit_trn,
                method = "rf",
                trControl = oob,
                tuneGrid = rf_grid)

# storing the bagged model for making predictions
hit_bag = train(Salary ~ ., data = hit_trn,
                method = "rf",
                trControl = oob,
                tuneGrid = data.frame(mtry = (ncol(hit_trn) - 1)))
```

```{r, solution = TRUE}
calc_rmse = function(actual, predicted) {
  sqrt(mean((actual - predicted) ^ 2))
}

gbm_tst_rmse = calc_rmse(predicted = predict(hit_gbm, hit_tst),
                         actual    = hit_tst$Salary)

rf_tst_rmse = calc_rmse(predicted = predict(hit_rf, hit_tst),
                        actual    = hit_tst$Salary)

bag_tst_rmse = calc_rmse(predicted = predict(hit_bag, hit_tst),
                         actual    = hit_tst$Salary)


hitters_results = data.frame(
  c("Boosting", "Random Forest", "Bagging"),
  c(min(hit_gbm$results$RMSE), min(hit_rf$results$RMSE), min(hit_bag$results$RMSE)),
  c(gbm_tst_rmse, rf_tst_rmse, bag_tst_rmse)
)
colnames(hitters_results) = c("Method", "Resampled RMSE", "Test RMSE")
kable_styling(kable(hitters_results, format = "html", digits = 4), full_width = FALSE)
```

***

# Exercise 5 (Concept Checks)

**[0.5 point each]** Answer the following questions based on your results from the three exercises. Yes this does mean that the total points total more than 30. The extra points are "buffer" points. The maximum points you are able to score is still 30.

### Leukemia

**(5.1.1)** How many observations are in the dataset? How many predictors are in the dataset?

- Predictors: `r ncol(leukemia) - 1`
- Observations: `r nrow(leukemia)`

**(5.1.2)** Based on the deviance plots, do you feel that `glmnet` considered enough $\lambda$ values for lasso?

**Yes.** We see a nice U-shaped CV error curve.

**(5.1.3)** Based on the deviance plots, do you feel that `glmnet` considered enough $\lambda$ values for ridge?

**No.** This plot suggests that if we were to try smaller lambda, we could achieve a lower devience (error).

**(5.1.4)** How does $k$-nearest neighbor compare to the penalized methods? Can you explain any difference?

KNN performs worse. This is expected in a high-dimensional setting that we have here due to the curse of dimensionality. (Although, it turns out that if we were to scale the predictors, KNN would actually work reasonably well.)

**(5.1.5)** Based on your results, which model would you choose? Explain.

The **ridge** model with the **larger** lambda. (Using the 1-SE rule.) This model performs much better than the lasso and KNN models. It also achieves the same CV accuracy as the ridge with a smaller lambda, but we prefer the model with a greater penalty, thus less chance of overfitting. 

### College

**(5.2.1)** Based on the table, which model do you prefer? Justify your answer.

Random forest, as it achieves the lowest error. Although, predicting college tuition to within 1700 versus 2000 dollars is not all that different, so an argument could be made for a more interpretable model.

**(5.2.2)** For both of the elastic net models, report the best tuning parameters from `caret`. For each, is this ridge, lasso, or somewhere in between? If in between, closer to which?

```{r, solution = TRUE}
fit_glmnet$bestTune
fit_glmnet_int$bestTune
```

Both have an $\alpha$ value of 0.1, so are in-between, but are closer to ridge.

**(5.2.3)** Did you scale the predictors when you used KNN? Should you have scaled the predictors when you used KNN?

Yes. Yes. A lower error is found using scaled predictors.

**(5.2.4)** Of the two KNN models which works better? Can you explain why?

Without interactions seems to work better. Adding all the interactions creates a high dimensional dataset, so we're suffering from the curse of dimensionality.

**(5.2.5)** What year is this dataset from? What was out-of-state tuition at UIUC at that time?

According to the documentation, 1995.

```{r message = FALSE, warning = FALSE, solution = TRUE}
College %>% filter(rownames(College) == "University of Illinois - Urbana") %>% select(Outstate)
```

Wow. Remember, this is for out-of-state.

### Timing

**(5.3.1)** Compare the time taken to tune each model. Is the difference between the OOB and CV result for the random forest similar to what you would have expected?

**Solution:** The speed-up for OOB is only about three times that of 5-fold CV, instead of the five times that would have been expected. There appears to be some additional overhead in using OOB.

```{r, solution = TRUE}
rf_cv_time["elapsed"] / rf_oob_time["elapsed"]
```

**(5.3.2)** Compare the tuned value of `mtry` for each of the random forests tuned. Do they choose the same model?

**Solution:** They choose the same model, although, there were only two to choose from, and they are not very different. In practice, the two methods may differ more.

**(5.3.3)** Compare the test accuracy of each of the four procedures considered. Briefly explain these results.

**Solution:** 
  
- Logistic: Performs the worst. This is expected as clearly a non-linear decision boundary is needed.
- Single Tree: Better than logistic, but not the best seen here. We see above that this is not a very deep tree. It will have non-linear boundaries, but since it uses binary splits, they will be rectangular regions.
- Random Forest: First note that both essentially fit the same model. (The exact forests will be different due to randomization.) By using many trees (500) the boundaries will become less rectangular than the single tree, and will better match the spiral data in the data.

- See below for plots of decision boundaries created by making predictions from the different models.

```{r, fig.height = 5, fig.width = 13, solution = TRUE, echo = FALSE, fig.align = "center"}
plot_grid = expand.grid(
  X1 = seq(min(sim_tst$X1) - 1, max(sim_tst$X1) + 1, by = 0.01),
  X2 = seq(min(sim_tst$X2) - 1, max(sim_tst$X2) + 1, by = 0.01)
)

glm_pred  = predict(sim_glm_cv, plot_grid)
tree_pred = predict(sim_tree_cv, plot_grid)
rf_pred   = predict(sim_rf_oob, plot_grid)

glm_col = ifelse(glm_pred == 1, "darkorange", "dodgerblue")
tree_col = ifelse(tree_pred == 1, "darkorange", "dodgerblue")
rf_col = ifelse(rf_pred == 1, "darkorange", "dodgerblue")

par(mfrow = c(1, 3))
plot(plot_grid$X1, plot_grid$X2, col = glm_col,
     xlab = "X1", ylab = "X2", pch = 20, main = "Logistic Regression",
     xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
plot(plot_grid$X1, plot_grid$X2, col = tree_col,
     xlab = "X1", ylab = "X2", pch = 20, main = "Single Tree",
     xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
plot(plot_grid$X1, plot_grid$X2, col = rf_col,
     xlab = "X1", ylab = "X2", pch = 20, main = "Random Forest",
     xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
```

### Salary

**(5.4.1)** Report the tuned value of `mtry` for the random forest.

```{r, solution = TRUE}
hit_rf$bestTune
```

**(5.4.2)** Create a plot that shows the tuning results for the tuning of the boosted tree model.

```{r, solution = TRUE, fig.align = "center"}
plot(hit_gbm)
```

**(5.4.3)** Create a plot of the variable importance for the tuned random forest.

```{r, solution = TRUE, echo = FALSE, fig.align = "center"}
varImpPlot(hit_rf$finalModel, main = "Variable Importance, Random Forest")
```

**(5.4.4)** Create a plot of the variable importance for the tuned boosted tree model.

```{r, solution = TRUE, echo = FALSE, fig.align = "center"}
plot(varImp(hit_gbm), main = "Variable Importance, Boosting")
```

**(5.4.5)** According to the random forest, what are the three most important predictors?

```{r, solution = TRUE, echo = FALSE}
names(importance(hit_rf$finalModel)[order(importance(hit_rf$finalModel), decreasing = TRUE), ][1:3])
```

**(5.4.6)** According to the boosted model, what are the three most important predictors?

```{r, solution = TRUE, echo = FALSE}
rownames(varImp(hit_gbm)$importance)[order(varImp(hit_gbm)$importance$Overall, decreasing = TRUE)][1:3]
```
